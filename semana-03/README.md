## SEMANA 3
Nesta semana estudaremos os desvios condicionais que você poderá implementar em seus programas, usando o comando "if..else". Além disso, estudaremos variáveis e expressões booleanas. Bom trabalho!
________________________
## AULA

<b>Expressões Booleanas (Tipo de dado "bool", operadores lógicos (and, or, not) e precedência entre operadores relacionais, lógicos e aritméticos)</b>

Vamos então aprender novo tipo de valor que nós temos diversas linguagens de programação e que é muito importante na computação, que são os valores booleanos ou as expressões booleanas. De onde vem esse nome booleano? Vem, é nome homenagem ao matemático britânico George Boole, que criou o que a gente chama de álgebra booleana. Ele foi matemático que estudou valores que podem ter apenas dois tipos de coisa, por exemplo, verdadeiro ou falso ou 0 e 1, ou ligado e desligado. Ele criou toda uma álgebra para manipular esses valores e como os computadores ali, internamente eles funcionam com código binário, essa álgebra booleana é muito apropriada para tratar vários aspectos aí da computação. Então particular, boa parte das linguagens de programação têm tipo de valor, tipo de dado que é o tipo booleano. Vamos então agora abrir o nosso interpretador Phyton e ver como funciona Phyton esses valores booleanos. Se eu fizer por exemplo 5 maior que 3, isso dá True. Toda vez que eu faço uma comparação ela vai dar ou verdadeira ou falsa, então esse tipo de valor que pode ser verdadeiro ou falso é valor booleano. Se eu fizer 18 é igual a nove vezes dois, isso vai dar verdadeiro também. Agora se eu botar x valor aqui assim e fizer x é menor que zero, isso vai dar falso. Particular se eu perguntar qual é o tipo de falso? Ele vai dizer, o tipo de falso é bool, o objeto falso é da classe bool, de booleano. A mesma coisa se eu perguntar: qual é o tipo de x maior que zero? Então a expressão x maior que zero é uma expressão da classe booleana, da classe bool. Agora com esse valores booleanos a gente pode criar expressões booleanas e pra isso a gente pode pegar operadores lógicos, operadores booleanos, tipo e, ou e agrupar esses valores booleanos. Vamos ver aqui exemplo com o e, com and primeiro. Então, eu posso dizer algo do tipo, se eu tenho o x que tem aquele valor, eu posso falar: x é maior que zero and x ao quadrado é maior que 100. Então, essa é uma expressão aqui que a gente chama expressão booleana, que eu tenho e lógico, o and que o resultado final só vai ser verdadeiro se ambos os lados forem verdadeiros, então se x for maior que zero e x ao quadrado for maior que 100, então o resultado final vai ser verdadeiro. Se dos dois for falso então o resultado final é falso. Nesse caso os dois são verdadeiros então o resultado final é verdadeiro, se fosse x menor que zero and x é igual a 12312. Isso aqui dá falso, porque o primeiro, primeiro valor booleano aqui, x maior que zero já é falso, então ele nem precisa verificar o segundo, é com certeza falso, porque é e lógico o and que nós temos. Outra opção é o or. O or ele vai escolher, o resultado do or vai ser verdadeiro se a primeira parte é verdadeira ou a segunda parte é verdadeira, então se eu fizer x menor que zero or x é igual a 12312, isso dá verdadeiro, porquê? Porque a primeira parte é falsa mas a segunda parte é verdadeira então, o resultado do ou, o ou ele vai ser verdadeiro se ou outro ou ambos forem verdadeiros. Outro tipo de valor que, operador lógico que nós temos, que é o mais simples de todos é o not. O not ele simplesmente inverte o valor de valor booleano. Então se x maior que zero, se isso é verdadeiro, not x maior que zero, vai ser falso. Particular o not False é True e not True é False. Eu posso fazer também: not not True vai ser verdadeiro, ele inverteu duas vezes ali o valor do verdadeiro voltou a ser verdadeiro. Uma coisa que nós podemos fazer é uma, aqui, vamos ver isto, uma tabela que a gente chama da tabela da verdade com os valores, eu abri aqui uma planilha no Libre Office. Então aqui o operador lógico and, se a primeira, primeiro valor é verdadeiro e o segundo valor é verdadeiro o resultado dessa expressão booleana vai ser verdadeiro. Se o primeiro é verdadeiro e o segundo é falso daí o resultado vai ser falso. Porque o and exige que ambos sejam verdadeiros. Se o primeiro é falso e o segundo é verdadeiro, sinto muito vai dar falso do mesmo jeito e se ambos forem falso, obviamente vai dar falso. Então, essa aqui é a tabela da verdade do operador and. O operador or é operador muito mais bonzinho não é? Porque, tanto faz se o primeiro for verdadeiro, ou o segundo for verdadeiro o resultado vai ser verdadeiro, então se os dois forem verdadeiros é verdadeiro, se o primeiro é verdadeiro e o segundo é falso é verdadeiro, se o primeiro é falso e o segundo é verdadeiro, também é verdadeiro. O único caso que or or dá falso é quando ambos são falso, daí também dá falso, não é? Aí ninguém é de ferro. Já o operador not é operador aquele simples, ele simplesmente muda o valor, então se eu tenho not True isso aqui da False, False e se e tenho not False, isso aqui dá True. Então isso aqui que a gente chama de: a tabela da verdade dos operadores lógicos, é algo interessante de a gente ter isso na cabeça, não é? Quando estivermos programando Phyton, muitos casos a gente vai ter, querer fazer combinações lógicas de valores lógicos, por exemplo, eu quero decidir se segunda-feira eu vou para a praia, alguém pergunta para você: você vai para a praia na segunda-feira? Daí você vai falar: eu vou para a praia na segunda-feira, se for feriado mesmo e nós não tivermos que trabalhar e se fizer sol, e se fizer sol, então eu posso dizer algo do tipo assim, vamos supor que eu tenho uma variável que chamava FizerSol, suponho que ela vale True e uma outra variável chamada, forFeriado e vamos supor que essa variável é False, daí eu digo que eu vouParaPraia se fizerSol and forFeriado. Então, o que é que o interpretador Phyton fez? Ele fez esse cálculo aqui do fizerSol and forFeriado e nesse caso aqui o resultado deu falso, porque o forFeriado foi falso. Se por acaso eu escolho outro dia que o forFeriado é verdadeiro, então eu vou colocar aqui verdadeiro no for feriado e vou calcular novamente aqui, vou refazer o cálculo. Refazendo o cálculo agora, agora eu vouParaPraia deu verdadeiro, que bom né? Porque vai estar fazendo sol e é feriado, então perfeito para eu ir para praia. Já exemplo de operador lógico ou, vamos supor que amigo convida você para ir num show de rock nesse final de semana e se perguntar, legal mas é muito caro? É meio caro o ingresso. Daí você fala: Eu vou perguntar para o meu pai, ver se ele pode me emprestar dinheiro para comprar o ingresso ou então, eu sei que tem uma rádio ali com uma promoção, que você ligando para a rádio respondendo uma pergunta às vezes ele dá ingresso de graça. Uma vez eu fiz isso, eu fui show do Hermeto Pascoal porque a Rádio Cultura estava dando ingresso de graça, acertei a pergunta, ganhei o ingresso. Então, como eu falaria isso? Eu posso falar algo do tipo: vouAoShow se eu receber, se meu pai pagar, então se eu receber paitrocinio ou, or, se rolarPromocao da rádio, então posso falar alguma coisa desse tipo, vou ao show se tiver paitrocinio ou rolar a promoção. Mas primeiro para eu poder calcular algo desse tipo eu preciso definir o valor dessas variáveis, então vamos só de exemplo. Se meu paitrocino aqui, por exemplo, não consegui convencer o meu pai ou vai ver que o meu pai não achou que era bom para minha educação musical ir nesse show, então não consegui aqui meu paitrocinio, por outro lado, ali o rolarPromoção. Eu sou muito sortudo, liguei para a rádio, consegui e ganhei o ingresso. Daí sim eu posso fazer aquele cálculo, vouAoShow igual a paitrocinio or rolarPromocao e daí qual é o valor aqui do vouAoShow? O vouAoShow é É verdadeiro, porque mesmo não tendo conseguido o patrocínio rolou a promoção e eu consegui como era operador ou ele permite que, ou ou outro, seja verdadeiro. Outra coisa interessante que a gente tem que olhar com cuidado, é a questão da precedência de operadores. Se a gente olhar aqui, essa é a tabela de precedência de operadores da linguagem Python. Então, se eu tenho uma expressão complexa, com vários operadores diferentes, tem uma certa ordem na qual esses operadores são calculados, então, o operador aqui de mais alto nível é a exponenciação, quando faço uma exponenciação com esse operador aqui. Então, se tiver uma expressão qualquer bem complexa ali, primeiro ele vai fazer a exponenciação, segundo lugar, ele vai fazer os operadores multiplicativos, que é a multiplicação, a divisão, a divisão inteira e o resto da divisão inteira. Depois vêm os aditivos, que é a soma e a subtração, depois os de comparação, igual, diferente, menor ou igual, maior ou igual, etc. E depois vêm os lógicos, sendo que os lógicos são nessa ordem, o not, depois o and e o que tem mais baixa precedência de todos é o or. Então, vamos ver exemplo. Se eu fizer uma operação como essa aqui: x maior que zero and deixa eu definir uma variável y aqui para usar nesse meu exemplo, então, vamos supor que o y é 50. Então, faço x maior que zero and not y é igual a 50 or x mais y é igual a 150. Se eu fizer essa operação aqui, como que o Python vai interpretar isso? Lembra? Pela ordem dos operadores, de todos os que estão aqui, essa soma é a que tem maior precedência. Então, ele vai fazer o x mais y aqui e vai calcular e vai, depois que tenhas as respostas de x mais y ele vai comparar para ver se é igual a 150 ou não e nesse caso não é porque o x era valor bem maior então, esse pedaço aqui vai dar false. Depois, ele vai fazer todas as comparações e o que tem precedência maior depois vai ser o not, então, ele vai pegar esse y igual a 50 que é valor, é verdadeiro, y igual a 50 é verdadeiro e vai fazer not, vai virar false, esse pedaço aqui vai virar false. Aí sim, ele vai executar o and então, x é maior que zero é verdadeiro com essa parte que a gente viu que era false ele vai fazer verdadeiro com false, vai dar false e daí, por último ele vai fazer esse or, então tudo isso aqui que deu false, mais com isso aqui que também, a gente viu é false então, o resultado final inteiro vai dar false, mas note que tá meio confuso a ordem que essas coisas vão acontecer, então quando você tem uma expressão complicada, o ideal é você colocar uns parêntesis aqui para ficar mais claro. É sempre ideal a gente escrever o código o mais claro possível. Então, para evitar qualquer dúvida, mesmo sendo redundante, é bom a gente colocar os parêntesis aqui para ficar bem claro que é que está sendo feito, por exemplo aqui eu vou colocar bastantes parêntesis para ficar bem claro a ordem das coisas. Então, assim, fica bem claro, não mudou nada, continua sendo false ali, mas é jeito mais elegante de escrever o código. Então agora quero que vocês entrem no interpretador Python no seu computador e brinquem pouco com variáveis, com valores booleanos, com essas expressões lógicas usando and, or, not, e expressões complexas sofisticadas, misturando comparações com operadores lógicos, com operadores aritméticos, então brinquem ali uns cinco a dez minutos no interpretador para você praticar bastante isso. 

_____________________________________
<b>Execução Condicional (if, if..else, biblioteca math, exemplo)</b>

Olá! Vamos então aprender uma coisa que a gente chama de execução condicional. Tem alguns momentos que a gente quer escrever determinado trecho de código, que só vai ser executado caso alguma condição seja satisfeita. Então, a gente não vai executar aquilo sempre, só alguns casos. E como que a gente faz isso? A gente faz com o comando if, que praticamente toda a linguagem de programação tem esse comando if, não é? Como é que o comando if? Eu digito aqui if, i f, não é, e daí eu digito uma condição. Essa condição vai ser uma expressão booleana cujo valor é verdadeiro ou falso, daí eu digito ':' e daí na linha de baixo eu coloco alguns espaços, por exemplo dois espaços ou quatro espaços para dar o que a gente chama de endentação, e daí, eu escrevo aqui o meu comando que eu quero que seja executado, está? Esse aqui é o formato genérico ali do comando if e, sempre assim. Se a condição for verdadeira ele executa o comando, caso contrário, se a condição não for verdadeira, for falsa, ele não executa o comando, ele vem aqui para a linha seguinte executar o, por exemplo o comando seguinte que está aqui, está? Vamos aqui exemplo no nosso interpretador. Então, eu posso, por exemplo, se eu tenho aqui temperatura é igual a 102. Daí, eu posso ter trecho de código que eu falo: if temperatura é maior que 100, daí, então, eu posso querer dizer que a aguaFerve =, recebe true. Se a temperatura for maior que 100 a água vai ferver, então, coloquei valor true nessa variável de aguaFerve. Então, se eu fizer executar isso aqui, se eu for olhar agora o valor dessa variável aguaFerve, ela está valendo true, porquê? Porque a temperatura é maior que 100. Agora, vamos supor que eu quero na verdade eu quero fazer mais do que comando, eu quero executar dois comandos caso a temperatura for maior que 100. Daí, o que eu posso fazer, voltando aqui a esse formato genérico aqui, eu posso colocar outros comandos aqui desde que eu use o mesmo, a mesma endentação. Então, se eu coloquei aqui quatro espaços, aqui eu coloco os mesmos quatro espaços, está? Então, dessa forma eu estou como se fosse criando bloco aqui que, todo esse bloco é executado, caso essa condição seja verdadeira. Note que aqui pode ter quantos comandos eu quiser desde que eu sempre use a mesma endentação. Posso ter dezenas aqui se quiser, comandos dentro de único if. Então, eu poderia escrever algo do tipo: se a temperatura é maior que 100, não só a aguaFerve como a evaporação, eu quero que ela receba "muito rápida". Então, executando isso aqui, não só a variável aguaFerve contém esse valor booleano true, como a variável evaporação, contém aqui string cujo conteúdo do string é "muito rápida". Então, uma única condição levando à execução de dois comandos. Então, isso é o que a gente chama de execução condicional, tem uma expressão booleana que, define se determinado pedaço de código vai executar ou não. Agora, tem alguns casos que você quer executar alguns comandos, caso a condição seja verdadeira mas, caso a condição seja falsa você quer executar outro grupo de comandos. Daí, como que a gente faz isso? A gente usa o if else. Então, é assim, if condição, os comandos, else, caso contrário, dois pontos, e daí, que a gente coloca outros comandos. Então, esses aí vão ser os comandos que vão ser executados caso seja verdadeira, três comandos diferentes, caso seja verdadeira e, aqui, ou mais comandos que vão ser executados caso seja falso. Então, vou colocar aqui, por exemplo, dois comandos mas, pode ser quantos você quiser. Então, nesse caso, se a condição for verdadeira ele executa apenas esses três, se a condição for falsa, ele executa apenas esses dois. E, ambos os casos depois que ele executou esses comandos do if else, ele, ambos os casos pula para o comando seguinte aqui, que é o comando que vem depois aqui do else sem essa endentação, note que não tem mais esses espaços que eu coloquei aqui no começo. Então, você vê que na linguagem Python esses espaços aqui são muito importantes. Tem outras linguagens de programação que simplesmente ignoram os espaços, os espaços não tem nenhum significado. Python tem esse significado de definir os blocos, particular, os blocos aí do if e do else, são identificados, são definidos com essa endentação. Vamos fazer exemplinho aqui de programinha. Eu vou abrir o meu editor de textos aqui, e eu vou criar novo programa. Então, vamos ver aqui exemplo de uso do if else, num caso ali pouquinho mais concreto. Vamos fazer programinha que eu vou perguntar aqui para o meu usuário, qual que é o tempo de jogo. Então, eu vou usar o comando input para fazer a pergunta e eu vou perguntar: "quanto tempo temos já jogado?" Eu vou perguntar isso, só que eu quero esse valor como número inteiro. Se eu fizer input ele sempre volta como string, como uma cadeia de carateres, eu vou converter isso aqui para inteiro colocando esse int aqui, e já resolve o meu problema. Dai eu vou falar o seguinte: if tempoDeJogo é menor ou igual a 90, "Quanto tempo temos já jogado?" não é, singular, se eu fizer if tempoDeJogo menor ou igual a 90, daí eu posso falar algo do tipo: "Ainda tem jogo pela frente", e posso falar alguma outra coisa, se eu gosto de futebol posso falar: "Que bom, eu adoro futebol". Você pode trocar pelo seu esporte preferido aqui, está, não precisa se ater ao futebol. Mas, por outro lado, else, eu posso falar caso contrário, ou seja se o tempo de jogo não é menor ou igual a 90, se ele é maior que 90, daí eu digo "Putz, está acabando o jogo" e, além disso, se o seu time estiver ganhando você pode falar "Apita logo, juiz!!!" Então, esse aqui é o nosso programa. Salvei aqui, num arquivo chamado jogo.py. Daí, eu posso executar aqui, Python, vou executar o Python 3, a versão 3, jogo.py e ele me pergunta: "Quanto temos já jogado?". Então, se já jogamos 45 minutos, ele vai falar: "Ainda tem jogo pela frente" "Que bom eu adoro futebol" Por outro lado, se já foram jogados ali 92 minutos, ele vai falar "Putz está acabando o jogo" "Apita logo, juiz!!!" Então, a gente vê exemplo ali, que a gente executa blocos diferentes de código, dependendo do que está acontecendo. Agora, eu vou querer que você use o if else para fazer exercício, desafio que eu vou dar para vocês. E o desafio é bem mais complexo do que a gente viu até agora, que é fazer programa que calcula as raízes de uma equação de segundo grau. Vejamos aqui se a gente tem uma equação quadrática não é? Uma equação desse tipo aqui ax2 mais bx mais c é igual a 0, não é, o que é que a gente tem nessa equação? x é variável, a gente tem essas constantes, esses parâmetros, o a, o b e o c, que são os valores de entrada ali para o nosso programa e, a gente vai, então, dizer qual é a a raiz dessa equação, a raiz você tem uma parábola assim, são os pontos que a parábola encontra ali o eixo x. Mas note que o if vai ser importante aqui porque tem três casos diferentes. Primeiro, lembra qual é a fórmula? A fórmula de Bhaskara, não é, Bhaskara é aquele matemático indiano que inventou essa fórmula de Bhaskara aqui não é, que diz que x é igual a menos b mais ou menos raiz quadrada de b2 menos 4ac dividido por 2a. Está aqui a fórmula de Bhaskara. Então, essa parte aqui que tem a raiz a gente chama de delta e, porque é que o if é importante? Porque se o delta for igual a zero, daí, essa equação aqui ela só tem uma raiz, porque essa parábola vai encostar aqui no ponto mínimo vai encostar aqui no zero, então ele só vai ter uma raiz, isso se o delta for igual a zero. Se o delta for negativo ela não vai ter raízes reais, as raízes vão ser imaginárias. Vamos fazer programa que calcule apenas raízes reais, então, nesse caso do delta for menor que zero, eu quero que o programa diga: "Esta equação não possui raízes reais". Se o delta for igual a zero ela vai dizer: "A raiz desta equação é" e o valor da raiz, se o delta for maior que zero estritamente, daí o seu programa vai falar: "As raízes da equação são", e vai dar a primeira raiz e vai dar a segunda raiz e, para isso você vai precisar do comando if, ou talvez mais do que comando if para discernir esses 3 casos diferentes. Agora, você já sabe tudo o que você precisa para calcular esse resultado não é, para aplicar essa fórmula e dar o resultado, os três possíveis resultados, com exceção de uma coisa, a gente ainda não viu como fazer raiz quadrada, não é? Toda a vez que você tiver necessidade de procurar algo novo na linguagem Python que você não sabe, o que é que você faz? Você vai ali no Google e você digita, por exemplo: Python documentation, nesse caso eu quero saber como se faz raiz quadrada, não é? Então, eu vou digitar inglês: square root, raiz quadrada inglês. E daí, o que é que a gente vê? Os dois primeiros links é a documentação do Python da versão 2.7 e da versão 3.5.1. Eu vou abrir essa versão mais recente aqui não é, versão 3.5.1, e a gente caiu nessa página aqui que é a documentação do módulo Math da linguagem Python. Então, é módulo que provê acesso a funções matemáticas definidas ali, não é, mathematical functions, particular, se eu buscar aqui por square root, a gente vê que essa função math.sqrt aqui, ela devolve a raiz quadrada de x. Então, vamos ver como usa ela. Se eu abrir aqui o meu interpretador Python e perguntar, por exemplo, qual a raiz quadrada math.sqrt de oito, e eu apertar enter, que é que acontece? Opa, deu erro, ele falou: " o nome math is not defined". E porquê? Quando você usa módulo externo que não é padrão, você precisa primeiro importar este módulo e a gente faz isso com o comando import. Então, simplesmente escrevo import math e a partir daí todas aquelas funções matemáticas do módulo math já estão disponíveis para mim. Então, se eu repetir a mesma coisa aqui, fizer math.sqrt(8) aí ele vai dar ali o valor da raiz quadrada de oito. Só para a gente ter a certeza que ele está calculando certo, vamos pegar a raiz quadrada de nove, que a gente sabe qual é, não é, a raiz quadrada de nove é três, então, pronto já temos uma forma de calcular. Então, se tiver uma variável delta lá que, vai ter todo cálculo ali, vamos supor que o delta deu isso aqui, e daí, você pode simplesmente fazer math.sqrt(delta) e você já tem ali a raiz quadrada do delta. Então, tudo isso é o que você precisa para fazer esse exercício. Então, vamos lá, com afinco, quero que vocês façam esse programa. Relembrando, esse programa vai receber como entrada três valores, o a, b e c, que são as constantes ali da equação de segundo grau e daí você vai usando a fórmula de Bhaskara, imprimir as raízes, sendo que tem três casos se delta é menor que zero você vai dizer que não tem raízes reais, se delta igual a zero você vai dizer que tem uma raiz real que é tal, se delta for maior que zero, você vai dizer que tem duasraízes reais que são: tal e tal. Então, trabalhe com afinco nesse problema, não desistam, está, não vai na primeira dificuldade já cair fora, fica lá até sair, está? Então, ao trabalho. 

#### DESAFIO:
