## SEMANA 3
Nesta semana estudaremos os desvios condicionais que você poderá implementar em seus programas, usando o comando "if..else". Além disso, estudaremos variáveis e expressões booleanas. Bom trabalho!
________________________
## AULA

<b>Expressões Booleanas (Tipo de dado "bool", operadores lógicos (and, or, not) e precedência entre operadores relacionais, lógicos e aritméticos)</b>

Vamos então aprender novo tipo de valor que nós temos diversas linguagens de programação e que é muito importante na computação, que são os valores booleanos ou as expressões booleanas. De onde vem esse nome booleano? Vem, é nome homenagem ao matemático britânico George Boole, que criou o que a gente chama de álgebra booleana. Ele foi matemático que estudou valores que podem ter apenas dois tipos de coisa, por exemplo, verdadeiro ou falso ou 0 e 1, ou ligado e desligado. Ele criou toda uma álgebra para manipular esses valores e como os computadores ali, internamente eles funcionam com código binário, essa álgebra booleana é muito apropriada para tratar vários aspectos aí da computação. Então particular, boa parte das linguagens de programação têm tipo de valor, tipo de dado que é o tipo booleano. Vamos então agora abrir o nosso interpretador Phyton e ver como funciona Phyton esses valores booleanos. Se eu fizer por exemplo 5 maior que 3, isso dá True. Toda vez que eu faço uma comparação ela vai dar ou verdadeira ou falsa, então esse tipo de valor que pode ser verdadeiro ou falso é valor booleano. Se eu fizer 18 é igual a nove vezes dois, isso vai dar verdadeiro também. Agora se eu botar x valor aqui assim e fizer x é menor que zero, isso vai dar falso. Particular se eu perguntar qual é o tipo de falso? Ele vai dizer, o tipo de falso é bool, o objeto falso é da classe bool, de booleano. A mesma coisa se eu perguntar: qual é o tipo de x maior que zero? Então a expressão x maior que zero é uma expressão da classe booleana, da classe bool. Agora com esse valores booleanos a gente pode criar expressões booleanas e pra isso a gente pode pegar operadores lógicos, operadores booleanos, tipo e, ou e agrupar esses valores booleanos. Vamos ver aqui exemplo com o e, com and primeiro. Então, eu posso dizer algo do tipo, se eu tenho o x que tem aquele valor, eu posso falar: x é maior que zero and x ao quadrado é maior que 100. Então, essa é uma expressão aqui que a gente chama expressão booleana, que eu tenho e lógico, o and que o resultado final só vai ser verdadeiro se ambos os lados forem verdadeiros, então se x for maior que zero e x ao quadrado for maior que 100, então o resultado final vai ser verdadeiro. Se dos dois for falso então o resultado final é falso. Nesse caso os dois são verdadeiros então o resultado final é verdadeiro, se fosse x menor que zero and x é igual a 12312. Isso aqui dá falso, porque o primeiro, primeiro valor booleano aqui, x maior que zero já é falso, então ele nem precisa verificar o segundo, é com certeza falso, porque é e lógico o and que nós temos. Outra opção é o or. O or ele vai escolher, o resultado do or vai ser verdadeiro se a primeira parte é verdadeira ou a segunda parte é verdadeira, então se eu fizer x menor que zero or x é igual a 12312, isso dá verdadeiro, porquê? Porque a primeira parte é falsa mas a segunda parte é verdadeira então, o resultado do ou, o ou ele vai ser verdadeiro se ou outro ou ambos forem verdadeiros. Outro tipo de valor que, operador lógico que nós temos, que é o mais simples de todos é o not. O not ele simplesmente inverte o valor de valor booleano. Então se x maior que zero, se isso é verdadeiro, not x maior que zero, vai ser falso. Particular o not False é True e not True é False. Eu posso fazer também: not not True vai ser verdadeiro, ele inverteu duas vezes ali o valor do verdadeiro voltou a ser verdadeiro. Uma coisa que nós podemos fazer é uma, aqui, vamos ver isto, uma tabela que a gente chama da tabela da verdade com os valores, eu abri aqui uma planilha no Libre Office. Então aqui o operador lógico and, se a primeira, primeiro valor é verdadeiro e o segundo valor é verdadeiro o resultado dessa expressão booleana vai ser verdadeiro. Se o primeiro é verdadeiro e o segundo é falso daí o resultado vai ser falso. Porque o and exige que ambos sejam verdadeiros. Se o primeiro é falso e o segundo é verdadeiro, sinto muito vai dar falso do mesmo jeito e se ambos forem falso, obviamente vai dar falso. Então, essa aqui é a tabela da verdade do operador and. O operador or é operador muito mais bonzinho não é? Porque, tanto faz se o primeiro for verdadeiro, ou o segundo for verdadeiro o resultado vai ser verdadeiro, então se os dois forem verdadeiros é verdadeiro, se o primeiro é verdadeiro e o segundo é falso é verdadeiro, se o primeiro é falso e o segundo é verdadeiro, também é verdadeiro. O único caso que or or dá falso é quando ambos são falso, daí também dá falso, não é? Aí ninguém é de ferro. Já o operador not é operador aquele simples, ele simplesmente muda o valor, então se eu tenho not True isso aqui da False, False e se e tenho not False, isso aqui dá True. Então isso aqui que a gente chama de: a tabela da verdade dos operadores lógicos, é algo interessante de a gente ter isso na cabeça, não é? Quando estivermos programando Phyton, muitos casos a gente vai ter, querer fazer combinações lógicas de valores lógicos, por exemplo, eu quero decidir se segunda-feira eu vou para a praia, alguém pergunta para você: você vai para a praia na segunda-feira? Daí você vai falar: eu vou para a praia na segunda-feira, se for feriado mesmo e nós não tivermos que trabalhar e se fizer sol, e se fizer sol, então eu posso dizer algo do tipo assim, vamos supor que eu tenho uma variável que chamava FizerSol, suponho que ela vale True e uma outra variável chamada, forFeriado e vamos supor que essa variável é False, daí eu digo que eu vouParaPraia se fizerSol and forFeriado. Então, o que é que o interpretador Phyton fez? Ele fez esse cálculo aqui do fizerSol and forFeriado e nesse caso aqui o resultado deu falso, porque o forFeriado foi falso. Se por acaso eu escolho outro dia que o forFeriado é verdadeiro, então eu vou colocar aqui verdadeiro no for feriado e vou calcular novamente aqui, vou refazer o cálculo. Refazendo o cálculo agora, agora eu vouParaPraia deu verdadeiro, que bom né? Porque vai estar fazendo sol e é feriado, então perfeito para eu ir para praia. Já exemplo de operador lógico ou, vamos supor que amigo convida você para ir num show de rock nesse final de semana e se perguntar, legal mas é muito caro? É meio caro o ingresso. Daí você fala: Eu vou perguntar para o meu pai, ver se ele pode me emprestar dinheiro para comprar o ingresso ou então, eu sei que tem uma rádio ali com uma promoção, que você ligando para a rádio respondendo uma pergunta às vezes ele dá ingresso de graça. Uma vez eu fiz isso, eu fui show do Hermeto Pascoal porque a Rádio Cultura estava dando ingresso de graça, acertei a pergunta, ganhei o ingresso. Então, como eu falaria isso? Eu posso falar algo do tipo: vouAoShow se eu receber, se meu pai pagar, então se eu receber paitrocinio ou, or, se rolarPromocao da rádio, então posso falar alguma coisa desse tipo, vou ao show se tiver paitrocinio ou rolar a promoção. Mas primeiro para eu poder calcular algo desse tipo eu preciso definir o valor dessas variáveis, então vamos só de exemplo. Se meu paitrocino aqui, por exemplo, não consegui convencer o meu pai ou vai ver que o meu pai não achou que era bom para minha educação musical ir nesse show, então não consegui aqui meu paitrocinio, por outro lado, ali o rolarPromoção. Eu sou muito sortudo, liguei para a rádio, consegui e ganhei o ingresso. Daí sim eu posso fazer aquele cálculo, vouAoShow igual a paitrocinio or rolarPromocao e daí qual é o valor aqui do vouAoShow? O vouAoShow é É verdadeiro, porque mesmo não tendo conseguido o patrocínio rolou a promoção e eu consegui como era operador ou ele permite que, ou ou outro, seja verdadeiro. Outra coisa interessante que a gente tem que olhar com cuidado, é a questão da precedência de operadores. Se a gente olhar aqui, essa é a tabela de precedência de operadores da linguagem Python. Então, se eu tenho uma expressão complexa, com vários operadores diferentes, tem uma certa ordem na qual esses operadores são calculados, então, o operador aqui de mais alto nível é a exponenciação, quando faço uma exponenciação com esse operador aqui. Então, se tiver uma expressão qualquer bem complexa ali, primeiro ele vai fazer a exponenciação, segundo lugar, ele vai fazer os operadores multiplicativos, que é a multiplicação, a divisão, a divisão inteira e o resto da divisão inteira. Depois vêm os aditivos, que é a soma e a subtração, depois os de comparação, igual, diferente, menor ou igual, maior ou igual, etc. E depois vêm os lógicos, sendo que os lógicos são nessa ordem, o not, depois o and e o que tem mais baixa precedência de todos é o or. Então, vamos ver exemplo. Se eu fizer uma operação como essa aqui: x maior que zero and deixa eu definir uma variável y aqui para usar nesse meu exemplo, então, vamos supor que o y é 50. Então, faço x maior que zero and not y é igual a 50 or x mais y é igual a 150. Se eu fizer essa operação aqui, como que o Python vai interpretar isso? Lembra? Pela ordem dos operadores, de todos os que estão aqui, essa soma é a que tem maior precedência. Então, ele vai fazer o x mais y aqui e vai calcular e vai, depois que tenhas as respostas de x mais y ele vai comparar para ver se é igual a 150 ou não e nesse caso não é porque o x era valor bem maior então, esse pedaço aqui vai dar false. Depois, ele vai fazer todas as comparações e o que tem precedência maior depois vai ser o not, então, ele vai pegar esse y igual a 50 que é valor, é verdadeiro, y igual a 50 é verdadeiro e vai fazer not, vai virar false, esse pedaço aqui vai virar false. Aí sim, ele vai executar o and então, x é maior que zero é verdadeiro com essa parte que a gente viu que era false ele vai fazer verdadeiro com false, vai dar false e daí, por último ele vai fazer esse or, então tudo isso aqui que deu false, mais com isso aqui que também, a gente viu é false então, o resultado final inteiro vai dar false, mas note que tá meio confuso a ordem que essas coisas vão acontecer, então quando você tem uma expressão complicada, o ideal é você colocar uns parêntesis aqui para ficar mais claro. É sempre ideal a gente escrever o código o mais claro possível. Então, para evitar qualquer dúvida, mesmo sendo redundante, é bom a gente colocar os parêntesis aqui para ficar bem claro que é que está sendo feito, por exemplo aqui eu vou colocar bastantes parêntesis para ficar bem claro a ordem das coisas. Então, assim, fica bem claro, não mudou nada, continua sendo false ali, mas é jeito mais elegante de escrever o código. Então agora quero que vocês entrem no interpretador Python no seu computador e brinquem pouco com variáveis, com valores booleanos, com essas expressões lógicas usando and, or, not, e expressões complexas sofisticadas, misturando comparações com operadores lógicos, com operadores aritméticos, então brinquem ali uns cinco a dez minutos no interpretador para você praticar bastante isso. 
